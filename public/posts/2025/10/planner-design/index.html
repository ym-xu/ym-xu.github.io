<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>planner design — Yiming Xu</title>
<meta name="description" content="A clean and fast content website" />
<link rel="alternate" type="application/rss+xml" href="/index.xml" title="Yiming Xu" />

<link rel="stylesheet" href="/css/styles.css?v=1763455480" />
<link rel="stylesheet" href="/css/custom.css?v=1763455480" />


<meta property="og:title" content="planner design — Yiming Xu" />
<meta property="og:description" content="A clean and fast content website" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://ym-xu.github.io/posts/2025/10/planner-design/" />

  </head>
  <body>
    <header>
      <div class="container header">
  <div class="brand">
    <a href="/">Yiming Xu</a>
  </div>
  <nav class="nav">
    
      
        <a class="nav-item" href="/posts/">Posts</a>
      
        <a class="nav-item" href="/about/">About</a>
      
    
    
      <button id="theme-toggle" aria-label="Toggle theme">🌓</button>
    
  </nav>
</div>


    </header>
    <main id="content" class="container">
      
  <article>
    <header class="post-header">
      <h1>planner design</h1>
      
      
        <div class="meta">
          <span>2025-10-07</span>
           · <span>1 min read</span>
           · <span>
            <a href="/tags/">#</a>
          </span>
        </div>
      
    </header>

    
    
      
        <aside class="toc"><nav id="TableOfContents">
  <ul>
    <li><a href="#我们嵌什么embedding-覆盖策略"><strong>我们嵌什么（Embedding 覆盖策略）</strong></a>
      <ul>
        <li><a href="#1-结构节点中间层"><strong>1) 结构节点（中间层）</strong></a></li>
        <li><a href="#2-叶子节点末端"><strong>2) 叶子节点（末端）</strong></a></li>
      </ul>
    </li>
    <li><a href="#为什么不直接-rag检索叶子-embedding-然后直接回答"><strong>为什么不直接 RAG：检索叶子 embedding 然后直接回答？</strong></a></li>
    <li><a href="#planner-里怎么用-embedding不是-rag但善用向量"><strong>Planner 里怎么用 embedding（不是 RAG，但善用向量）</strong></a></li>
    <li><a href="#嵌所有节点会不会太多"><strong>嵌所有节点会不会太多？</strong></a></li>
    <li><a href="#小结给论文复审"><strong>小结（给论文/复审）</strong></a></li>
  </ul>
</nav></aside>
      
    

    <div class="content"><ul>
<li>
<p><strong>我们会给“层次节点 + 叶子节点”都建 embedding</strong>（分层、分模态），不是只嵌入中间节点，也不是只嵌入叶子。</p>
</li>
<li>
<p><strong>为什么不直接像 RAG 一样“扔进向量库→取前 k 段就回答”</strong>？因为我们的任务大量涉及版面结构、跨页聚合、图表计数/读数、多模态对齐与可解释路径。直接 RAG 检索段落 embedding，既容易漏（比如多子图拆分），也容易错（取到语义近但版面不对的段落），更难做<strong>可复现的“导航→观测→推理”链路。我们的设计把 embedding 当作“导航提示”，真正的信息提取必须落在 Observer 的结构/版面感知</strong>上。</p>
</li>
</ul>
<h2 id="我们嵌什么embedding-覆盖策略"><strong>我们嵌什么（Embedding 覆盖策略）</strong></h2>
<h3 id="1-结构节点中间层"><strong>1) 结构节点（中间层）</strong></h3>
<ul>
<li>
<p><strong>L1/L2/L3 section</strong>：对每个章节节点生成<strong>summary</strong>（80–150 token），再对 summary 做 embedding。</p>
<p>用途：Planner 的<strong>第一跳定向</strong>（先找可能的章节窗口，而不是一开始就扫全书）。</p>
</li>
</ul>
<h3 id="2-叶子节点末端"><strong>2) 叶子节点（末端）</strong></h3>
<ul>
<li>
<p><strong>text 段落 / list_item</strong>：直接对清洗后的文本做 embedding（过长则分片，保留 page_idx+bbox）。</p>
</li>
<li>
<p><strong>table</strong>：用“结构化 markdown / HTML 预览 + caption”拼成短摘要再嵌（避免生吞整表）。</p>
</li>
<li>
<p><strong>image/figure</strong>：不嵌像素；嵌的是“<strong>caption/子标题/legend OCR 汇总 + VLM 摘要</strong>”。</p>
</li>
</ul>
<blockquote>
<p>我们还会把图的 <strong>page_idx、bbox、figure_id</strong> 保存在节点里，供观测时定位。</p></blockquote>
<blockquote>
<p>这样一来，我们有“<strong>粗粒度（章级）</strong> + <strong>细粒度（叶级）</strong>”两套索引：
章级用于 <strong>Planner 的窗口选择</strong>；
叶级用于 <strong>窗口内的细检索（第二跳）</strong>，比如该章节里的具体表格/图例/段落。</p></blockquote>
<hr>
<h2 id="为什么不直接-rag检索叶子-embedding-然后直接回答"><strong>为什么不直接 RAG：检索叶子 embedding 然后直接回答？</strong></h2>
<p>我们确实也会做 RAG baseline（用于论文对比），但我们的主系统不这么干，原因很现实：</p>
<ol>
<li>
<p><strong>结构敏感任务</strong></p>
<p>“如何跨页聚合？”“同一图的 3 个子图被切开了怎么办？”“同一章节有多个并列图/表要计数怎么办？”</p>
<ul>
<li>
<p>RAG 抽段落 → 取前 k → 回答，很容易<strong>漏并列兄弟</strong>或者<strong>跨页关联不全</strong>。</p>
</li>
<li>
<p>我们的 Planner 先定位 <strong>章节窗口</strong>，Observer 再按 <strong>read_order + sibling 半径</strong> 把<strong>并列图/表</strong>一起观察，<strong>可显式补漏</strong>（REPLAN）。</p>
</li>
</ul>
</li>
<li>
<p><strong>多模态问题必须落地到版面</strong></p>
<p>诸如“有几个折线图”“这张图上蓝线数值是多少”“哪个图标题含 mudslinging”等：</p>
<ul>
<li>
<p>RAG 的文本检索<strong>无法可靠定位图像本体</strong>；</p>
</li>
<li>
<p>我们在 Observer 里<strong>真的去看图片/表格节点</strong>（OCR legend、VLM 读图），并且把<strong>图—文—页</strong>的相对关系用 bbox/邻接维护，<strong>可解释</strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>可控的“导航→观测→推理”循环</strong></p>
<ul>
<li>
<p>我们希望流程是：<strong>embedding（提示方向）→ summary（人类可读规划）→ 精准观测（结构感知）→ 推理</strong>。</p>
</li>
<li>
<p>直接 RAG 会把“规划”和“观测”混在一起（一次向量检索当答案），很难做<strong>replan</strong>和<strong>证据路径</strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>减少“语义相近但上下文错位”的误检</strong></p>
<ul>
<li>
<p>例：问题是“有多少张和 mudslinging 相关的图表”，文本里到处会有“negative”“媒体批评”等词；</p>
</li>
<li>
<p>RAG 检索易捞到一堆“看似相关”的段落；</p>
</li>
<li>
<p>我们流程里 Planner 先定章节 → Observer 只看<strong>那一章里的图表和标题/legend</strong> → <strong>严格计数</strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>准确计数/统计</strong></p>
<ul>
<li>
<p>“多少页面至少有一张折线图”“多少表含 ‘F1’ 指标”…</p>
</li>
<li>
<p>这类题<strong>必须版面遍历 + 规则感知</strong>，不是“检索几段文本”就能稳的。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>一句话：<strong>RAG 更偏“找可能的句子”；我们的系统偏“找准位置，取对证据，然后再回答”。</strong></p></blockquote>
<blockquote>
<p>在“需要结构/版面/多模态/计数/可解释”的文档问答里，这差异很关键。</p></blockquote>
<hr>
<h2 id="planner-里怎么用-embedding不是-rag但善用向量"><strong>Planner 里怎么用 embedding（不是 RAG，但善用向量）</strong></h2>
<p>我们用 embedding 做 <strong>两段式导航</strong>：</p>
<ul>
<li>
<p><strong>Coarse（章级）</strong>：</p>
<p>用问题 + hints（同义/外语/别名）对 <strong>section-summary 索引</strong> 做相似度检索，取 top-K 章节窗口。</p>
</li>
<li>
<p><strong>Fine（叶级 within-window）</strong>：</p>
<p>对入围章节的<strong>叶节点索引</strong>再做一次小范围相似度检索（图/表/段落），给 Observer 一个更聚焦的观察清单。</p>
</li>
</ul>
<blockquote>
<p>两级检索都只是“确定去哪儿看”，<strong>不直接当答案</strong>；真正的内容读取交给 Observer（带结构和版面规则）。</p></blockquote>
<hr>
<h2 id="嵌所有节点会不会太多"><strong>嵌所有节点会不会太多？</strong></h2>
<p>我们有几条工程约束：</p>
<ul>
<li>
<p><strong>图/表</strong>只嵌<strong>caption+legend OCR 摘要</strong>，<strong>不嵌原图像</strong>（向量体积可控）。</p>
</li>
<li>
<p><strong>长段落</strong>按<strong>层内分片</strong>（比如 300–500 token），保留 page_idx 与 bbox，便于回跳。</p>
</li>
<li>
<p><strong>层级裁剪</strong>：章节嵌 L1–L3，L4+（很细）通常不嵌，作为“窗口内二跳”由叶级处理。</p>
</li>
<li>
<p><strong>类型过滤</strong>：检索时可以 type in {&ldquo;section&rdquo;,&ldquo;image&rdquo;,&ldquo;table&rdquo;} 限制，减少干扰。</p>
</li>
</ul>
<hr>
<h2 id="小结给论文复审"><strong>小结（给论文/复审）</strong></h2>
<ul>
<li>
<p><strong>我们不反对 embedding 检索</strong>，而是把它<strong>限定为“导航提示”</strong>；</p>
</li>
<li>
<p><strong>回答必须源自结构化观测</strong>（可复验的页码、图表、标题、legend 证据），<strong>提升可靠性与可解释性</strong>；</p>
</li>
<li>
<p>对于“结构/多模态/跨页聚合/计数”这类题，<strong>Agent 的分阶段策略</strong>比“RAG 一步到位”<strong>更稳定且可重跑</strong>；</p>
</li>
<li>
<p>同时，我们保留 RAG baseline 和兜底路径，公平对比并提高系统鲁棒性。</p>
</li>
</ul>
<p>before  build the context window, do embedding based retrieval first.</p>
</div>

    <nav class="pager">
      <a class="prev" href="/posts/2025/10/planner-work-process/">← planner work process</a>
      <a class="next" href="/posts/2025/10/"> →</a>
    </nav>
  </article>

    </main>
    <footer>
      <div class="container footer">
  <div class="left">
    <small>© 2025 Yiming Xu</small>
  </div>
  <div class="right">
    <a href="/index.xml">RSS</a>
  </div>
</div>


    </footer>
    <script>

(function() {
  const key = 'prefers-color-scheme';
  const btn = document.getElementById('theme-toggle');
  const root = document.documentElement;
  function applyTheme(t){ root.setAttribute('data-theme', t); }
  function current(){ return localStorage.getItem(key) || 'auto'; }
  function init(){
    const t = current();
    if (t === 'dark' || (t === 'auto' && window.matchMedia('(prefers-color-scheme: dark)').matches)) applyTheme('dark');
    if (btn) btn.addEventListener('click', () => {
      const now = root.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
      applyTheme(now); localStorage.setItem(key, now);
    });
  }
  document.addEventListener('DOMContentLoaded', init);
})();
</script>







  </body>
</html>
